const { CommandInteraction, MessageEmbed, Client } = require("discord.js");

module.exports = {
    name: "music",
    description: "Complete music system",
    options: [
        {
            name: "play",
            description: "Play a song.",
            type: "SUB_COMMAND",
            options: [
                {
                    name: "song",
                    description: "Provide a name or URL of the song.",
                    type: "STRING",
                    required: true 
                }
            ]
        },
        {
            name: "volume",
            description: "Alter the volume.",
            type: "SUB_COMMAND",
            options: [
                {
                    name: "percent",
                    description: "10 = 10%",
                    type: "NUMBER",
                    required: true 
                }
            ]
        },
        {
            name: "settings",
            description: "Select an option:",
            type: "SUB_COMMAND",
            options: [
                {
                    name: "options",
                    description: "Select an option:",
                    type: "STRING",
                    required: true,
                    choices: [
                        {name: "üî¢ Music Queue", value: "queue"},
                        {name: "‚è© Skip Song", value: "skip"},
                        {
                            name: "üîΩ Jump Song",
                            value: "jump",
                            type: "SUB_COMMAND",
                            choices: [
                                {
                                    name: "position",
                                    description: "Provide the position of the song.",
                                    type: "NUMBER",
                                    required: true 
                                }
                            ]
                        },
                        {name: "‚è∏ Pause Song",value: "pause"},
                        {name: "‚èØ Resume Song", value: "resume"},
                        {name: "‚èπ Clear Qu  eue", value: "clear"},
                        {name: "üîÄ Shuffle Queue", value: "shuffle"},
                        {name: "üîÇ Autoplay", value: "autoPlay"},
                        {name: "üîÑ Add a Related Song", value: "relatedSong"},
                        {name: "üîÅ Loop Mode", value: "loop"},
                    ]
                }
            ]
        }
    ],
    /**
     * @param {CommandInteraction   } interaction 
     * @param {Client} client 
     */
    async execute(interaction, client) {
        const { options, member, guild, channel } = interaction;
        const voiceChannel = member.voice.channel;

        if (!voiceChannel)
        interaction.reply({content: "You must be in a voice channel to use music commands.", ephemeral: true});

        if (guild.me.voice.channelId && voiceChannel.id !== guild.me.voice.channelId)
        interaction.reply({content: `I'm already in <#${guild.me.voice.channelId}>`, ephemeral: true});
        
        try {
            switch (options.getSubcommand()) {
                case "play" : {
                    client.distube.play( voiceChannel, options.getString("song"), { textChannel: channel, member: member});
                    return interaction.reply({content: "Searching..."})
                    .then(_msg => {setTimeout(() => interaction.deleteReply(), 3000)}).catch(e=>console.log(e));
                }
                case "volume" : {
                    const Volume = options.getNumber("percent");
                    if (Volume > 100 || Volume < 1) 
                    return interaction.reply({content: "You have to specify between 1-100.", ephemeral: true});

                    client.distube.setVolume(voiceChannel, Volume);
                    return interaction.reply({content: `Volume has been set to \`${Volume}%\``})
                    .then(_msg => {setTimeout(() => interaction.deleteReply(), 5000)}).catch(e=>console.log(e));
                }
                case "settings": {
                    const queue = await client.distube.getQueue(voiceChannel); 

                    if (!queue)
                    return interaction.reply({content: "There is no queue."});

                    switch (options.getString("options")) {
                        case "skip": {
                            await queue.skip(voiceChannel);
                            return interaction.reply({content: "‚è© Song has been skipped."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "jump": {
                            await queue.jump(voiceChannel, options.getNumber("position"));
                            return interaction.reply({content: "‚è© Song has been skipped."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "pause": {
                            await queue.pause(voiceChannel);
                            return interaction.reply({content: "‚è∏ Song has been paused."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "resume": {
                            await queue.resume(voiceChannel);
                            return interaction.reply({content: "‚èØ Song has been resumed."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "clear": {
                            await queue.stop(voiceChannel);
                            return interaction.reply({content: "‚èπ Song has been cleared."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "shuffle": {
                            await queue.shuffle(voiceChannel);
                            return interaction.reply({content: "üîÄ Song has been shuffled."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "autoPlay": {
                            let Mode = await queue.toggleAutoplay(voiceChannel);
                            return interaction.reply({content: `üîÇ Autoplay is set to ${Mode ? "On": "Off"}`})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "relatedSong": {
                            await queue.addRelatedSong(voiceChannel);
                            return interaction.reply({content: "üîÑ Related Song has been added."})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "loop": {
                            let Mode2 = await client.distube.setRepeatMode(queue);
                            return interaction.reply({content: `üîÅ Loop is set to ${Mode2 = Mode2 ? Mode2 == 2 ? "Queue" : "Song" : "Off"}`})
                            .then(_msg => {setTimeout(() => interaction.deleteReply(), 10000)}).catch(e=>console.log(e));
                        }
                        case "queue": {
                            return interaction.reply({embeds: [new MessageEmbed()
                            .setColor("RANDOM")
                            .setDescription(`__Now Playing:__\n${queue.songs.map((song, id) => `**[${song.name}](${song.url})** | \`${song.formattedDuration}\` | \`Requested By: ${song.user.tag}\``).slice(0, 1).join("\n")}\n\n__Up Next:__\n${queue.songs.map((song, id) => `**${id}**. **[${song.name}](${song.url})** | \`${song.formattedDuration}\` | \`Requested By: ${song.user.tag}\``).slice(1, 11).join("\n")}`)
                            ]}).then(_msg => {setTimeout(() => interaction.deleteReply(), 10*1000)}).catch(e=>console.log(e));
                        }
                    }
                    return;
                }
            }
        } catch (e) {
            const errorEmbed = new MessageEmbed()
            .setColor("RANDOM")
            .setDescription(`‚õî Alert: ${e}`)
            return interaction.reply({embeds: [errorEmbed]});
        }
    } 
}
